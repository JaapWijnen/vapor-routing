{"primaryContentSections":[{"kind":"declarations","declarations":[{"platforms":["Linux"],"tokens":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoder","kind":"identifier"}],"languages":["swift"]}]},{"kind":"content","content":[{"level":3,"type":"heading","anchor":"Purpose","text":"Purpose"},{"inlineContent":[{"text":"A ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" provides a simplified API for handling streams of incoming data that can be broken","type":"text"},{"text":" ","type":"text"},{"text":"up into messages. This API boils down to two methods: ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":". These two methods, when","type":"text"},{"text":" ","type":"text"},{"text":"implemented, will be used by a ","type":"text"},{"code":"ByteToMessageHandler","type":"codeVoice"},{"text":" paired with a ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" to decode the","type":"text"},{"text":" ","type":"text"},{"text":"incoming byte stream into a sequence of messages.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The reason this helper exists is to smooth away some of the boilerplate and edge case handling code that","type":"text"},{"text":" ","type":"text"},{"text":"is often necessary when implementing parsers in a SwiftNIO ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":". A ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" ","type":"text"},{"text":"never needs to worry about how inbound bytes will be buffered, as ","type":"text"},{"type":"codeVoice","code":"ByteToMessageHandler"},{"text":" deals with that","type":"text"},{"text":" ","type":"text"},{"text":"automatically. A ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" also never needs to worry about memory exclusivity violations","type":"text"},{"text":" ","type":"text"},{"text":"that can occur when re-entrant ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":" operations occur, as ","type":"text"},{"type":"codeVoice","code":"ByteToMessageHandler"},{"text":" will deal with","type":"text"},{"text":" ","type":"text"},{"text":"those as well.","type":"text"}],"type":"paragraph"},{"level":3,"type":"heading","anchor":"Implementing-ByteToMessageDecoder","text":"Implementing ByteToMessageDecoder"},{"inlineContent":[{"type":"text","text":"A type that implements "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" may implement two methods: decode and decodeLast. Implementations"},{"type":"text","text":" "},{"type":"text","text":"must implement decode: if they do not implement decodeLast, a default implementation will be used that"},{"type":"text","text":" "},{"type":"text","text":"simply calls decode."}],"type":"paragraph"},{"inlineContent":[{"code":"decode","type":"codeVoice"},{"text":" is the main decoding method, and is the one that will be called most often. ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" is invoked","type":"text"},{"text":" ","type":"text"},{"text":"whenever data is received by the wrapping ","type":"text"},{"code":"ByteToMessageHandler","type":"codeVoice"},{"text":". It is invoked with a ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" containing","type":"text"},{"text":" ","type":"text"},{"text":"all the received data (including any data previously buffered), as well as a ","type":"text"},{"code":"ChannelHandlerContext","type":"codeVoice"},{"text":" that can be","type":"text"},{"text":" ","type":"text"},{"text":"used in the ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" function.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"decode"},{"text":" is called in a loop by the ","type":"text"},{"type":"codeVoice","code":"ByteToMessageHandler"},{"text":". This loop continues until one of two cases occurs:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The input "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" has no more readable bytes (i.e. "},{"type":"codeVoice","code":".readableBytes == 0"},{"type":"text","text":"); OR"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"decode","type":"codeVoice"},{"type":"text","text":" method returns "},{"code":".needMoreData","type":"codeVoice"},{"type":"text","text":"."}]}]}],"type":"orderedList"},{"inlineContent":[{"text":"The reason this method is invoked in a loop is to ensure that the stream-like properties of inbound data are","type":"text"},{"text":" ","type":"text"},{"text":"respected. It is entirely possible for ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" to receive either fewer bytes than a single message,","type":"text"},{"text":" ","type":"text"},{"text":"or multiple messages in one go. Rather than have the ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" handle all of the complexity of this,","type":"text"},{"text":" ","type":"text"},{"text":"the logic can be boiled down to a single choice: has the ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" been able to move the state forward","type":"text"},{"text":" ","type":"text"},{"text":"or not? If it has, rather than containing an internal loop it may simply return ","type":"text"},{"code":".continue","type":"codeVoice"},{"text":" in order to request that","type":"text"},{"text":" ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" be invoked again immediately. If it has not, it can return ","type":"text"},{"code":".needMoreData","type":"codeVoice"},{"type":"text","text":" to ask to be left alone until more"},{"type":"text","text":" "},{"type":"text","text":"data has been returned from the network."}],"type":"paragraph"},{"inlineContent":[{"text":"Essentially, if the next parsing step could not be taken because there wasn’t enough data available, return ","type":"text"},{"type":"codeVoice","code":".needMoreData"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Otherwise, return ","type":"text"},{"type":"codeVoice","code":".continue"},{"text":". This will allow a ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" implementation to ignore the awkward way data","type":"text"},{"text":" ","type":"text"},{"text":"arrives from the network, and to just treat it as a series of ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":" calls.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"decodeLast","type":"codeVoice"},{"text":" is a cousin of ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":". It is also called in a loop, but unlike with ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" this loop will only ever","type":"text"},{"text":" ","type":"text"},{"text":"occur once: when the ","type":"text"},{"code":"ChannelHandlerContext","type":"codeVoice"},{"text":" belonging to this ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" is about to become invalidated.","type":"text"},{"text":" ","type":"text"},{"text":"This invalidation happens in two situations: when EOF is received from the network, or when the ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" ","type":"text"},{"text":"is being removed from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":". The distinction between these two states is captured by the value of","type":"text"},{"text":" ","type":"text"},{"code":"seenEOF","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In this condition, the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" must now produce any final messages it can with the bytes it has"},{"type":"text","text":" "},{"type":"text","text":"available. In protocols where EOF is used as a message delimiter, having "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" called with "},{"type":"codeVoice","code":"seenEOF == true"},{"type":"text","text":" "},{"type":"text","text":"may produce further messages. In other cases, "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" may choose to deliver any buffered bytes as “leftovers”,"},{"type":"text","text":" "},{"type":"text","text":"either in error messages or via "},{"type":"codeVoice","code":"channelRead"},{"type":"text","text":". This can occur if, for example, a protocol upgrade is occurring."}],"type":"paragraph"},{"inlineContent":[{"text":"As with ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":", ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" is invoked in a loop. This allows the same simplification as ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" allows: when","type":"text"},{"text":" ","type":"text"},{"text":"a message is completely parsed, the ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" function can return ","type":"text"},{"code":".continue","type":"codeVoice"},{"text":" and be re-invoked from the top,","type":"text"},{"text":" ","type":"text"},{"text":"rather than containing an internal loop.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Note that the value of ","type":"text"},{"code":"seenEOF","type":"codeVoice"},{"text":" may change between calls to ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" in some rare situations.","type":"text"}],"type":"paragraph"},{"level":3,"type":"heading","anchor":"Implementers-Notes","text":"Implementers Notes"},{"inlineContent":[{"type":"text","text":"\/\/\/ "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" will turn your "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" into a "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":". "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" "},{"type":"text","text":"also solves a couple of tricky issues for you. Most importantly, in a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" you do "},{"inlineContent":[{"text":"not","type":"text"}],"type":"emphasis"},{"type":"text","text":" need to"},{"type":"text","text":" "},{"type":"text","text":"worry about re-entrancy. Your code owns the passed-in "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" for the duration of the "},{"type":"codeVoice","code":"decode"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" call and"},{"type":"text","text":" "},{"type":"text","text":"can modify it at will."}],"type":"paragraph"},{"inlineContent":[{"text":"If a custom frame decoder is required, then one needs to be careful when implementing","type":"text"},{"text":" ","type":"text"},{"text":"one with ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":". Ensure there are enough bytes in the buffer for a","type":"text"},{"text":" ","type":"text"},{"text":"complete frame by checking ","type":"text"},{"code":"buffer.readableBytes","type":"codeVoice"},{"text":". If there are not enough bytes","type":"text"},{"text":" ","type":"text"},{"text":"for a complete frame, return without modifying the reader index to allow more bytes to arrive.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To check for complete frames without modifying the reader index, use methods like "},{"code":"buffer.getInteger","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"You  "},{"type":"emphasis","inlineContent":[{"type":"text","text":"MUST"}]},{"type":"text","text":" use the reader index when using methods like "},{"code":"buffer.getInteger","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For example calling "},{"code":"buffer.getInteger(at: 0)","type":"codeVoice"},{"type":"text","text":" is assuming the frame starts at the beginning of the buffer, which"},{"type":"text","text":" "},{"type":"text","text":"is not always the case. Use "},{"code":"buffer.getInteger(at: buffer.readerIndex)","type":"codeVoice"},{"type":"text","text":" instead."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If you move the reader index forward, either manually or by using one of "},{"type":"codeVoice","code":"buffer.read*"},{"type":"text","text":" methods, you must ensure"},{"type":"text","text":" "},{"type":"text","text":"that you no longer need to see those bytes again as they will not be returned to you the next time "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" is"},{"type":"text","text":" "},{"type":"text","text":"called. If you still need those bytes to come back, consider taking a local copy of buffer inside the function to"},{"type":"text","text":" "},{"type":"text","text":"perform your read operations on."}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" passed in as ","type":"text"},{"type":"codeVoice","code":"buffer"},{"text":" is a slice of a larger buffer owned by the ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" ","type":"text"},{"text":"implementation. Some aspects of this buffer are preserved across calls to ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":", meaning that any changes to","type":"text"},{"text":" ","type":"text"},{"text":"those properties you make in your ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":" method will be reflected in the next call to decode. In particular,","type":"text"},{"text":" ","type":"text"},{"text":"moving the reader index forward persists across calls. When your method returns, if the reader index has advanced,","type":"text"},{"text":" ","type":"text"},{"text":"those bytes are considered “consumed” and will not be available in future calls to ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Please note, however, that the numerical value of the ","type":"text"},{"type":"codeVoice","code":"readerIndex"},{"text":" itself is not preserved, and may not be the same","type":"text"},{"text":" ","type":"text"},{"text":"from one call to the next. Please do not rely on this numerical value: if you need","type":"text"},{"text":" ","type":"text"},{"text":"to recall where a byte is relative to the ","type":"text"},{"type":"codeVoice","code":"readerIndex"},{"text":", use an offset rather than an absolute value.","type":"text"}],"type":"paragraph"},{"level":3,"type":"heading","anchor":"Using-ByteToMessageDecoder","text":"Using ByteToMessageDecoder"},{"inlineContent":[{"type":"text","text":"To add a "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" to the "},{"code":"ChannelPipeline","type":"codeVoice"},{"type":"text","text":" use"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["channel.pipeline.addHandler(ByteToMessageHandler(MyByteToMessageDecoder()))"]}]}],"relationshipsSections":[{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder"],"kind":"relationships","type":"inheritedBy","title":"Inherited By"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/SNIHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOWebSocket\/WebSocketFrameDecoder"],"kind":"relationships","type":"conformingTypes","title":"Conforming Types"}],"topicSections":[{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/InboundOut"],"title":"Associated Types"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decode(context:buffer:)","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/wrapInboundOut(_:)"],"title":"Instance Methods"}],"variants":[{"paths":["\/documentation\/niocore\/bytetomessagedecoder"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"symbol","abstract":[{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":"s decode bytes in a stream-like fashion from ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" to another message type.","type":"text"}],"metadata":{"modules":[{"name":"NIOCore"}],"externalID":"s:7NIOCore20ByteToMessageDecoderP","roleHeading":"Protocol","navigatorTitle":[{"text":"ByteToMessageDecoder","kind":"identifier"}],"role":"symbol","symbolKind":"protocol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoder","kind":"identifier"}],"title":"ByteToMessageDecoder"},"schemaVersion":{"patch":0,"minor":3,"major":0},"identifier":{"url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder","interfaceLanguage":"swift"},"sections":[],"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"references":{"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decoderRemoved(context:)-sa8l":{"url":"\/documentation\/niocore\/bytetomessagedecoder\/decoderremoved(context:)-sa8l","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"decoderRemoved"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","text":"ChannelHandlerContext"},{"kind":"text","text":")"}],"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l","title":"decoderRemoved(context:)","required":true,"type":"topic","abstract":[{"type":"text","text":"Called once this "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" is removed from the "},{"code":"ChannelPipeline","type":"codeVoice"},{"text":".","type":"text"}],"role":"symbol","defaultImplementations":1},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decoderAdded(context:)-7trzq":{"role":"symbol","type":"topic","url":"\/documentation\/niocore\/bytetomessagedecoder\/decoderadded(context:)-7trzq","abstract":[{"type":"text","text":"Called when this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is added to the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":"."}],"title":"decoderAdded(context:)","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"decoderAdded","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","text":"ChannelHandlerContext","kind":"typeIdentifier"},{"text":")","kind":"text"}],"defaultImplementations":1,"required":true,"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOSingleStepByteToMessageDecoder":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSingleStepByteToMessageDecoder"}],"kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"NIOSingleStepByteToMessageDecoder"}],"url":"\/documentation\/niocore\/niosinglestepbytetomessagedecoder","abstract":[{"type":"text","text":"A simplified version of "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" that can generate zero or one messages for each invocation of "},{"code":"decode","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Having ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" return an optional message avoids re-entrancy problems, since the functions relinquish exclusive access","type":"text"},{"text":" ","type":"text"},{"text":"to the ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" when returning. This allows for greatly simplified processing.","type":"text"}],"title":"NIOSingleStepByteToMessageDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/WriteObservingByteToMessageDecoder":{"kind":"symbol","title":"WriteObservingByteToMessageDecoder","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WriteObservingByteToMessageDecoder","kind":"identifier"}],"abstract":[{"type":"text","text":"Some "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s need to observe "},{"type":"codeVoice","code":"write"},{"type":"text","text":"s (which are outbound events). "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s which"},{"type":"text","text":" "},{"type":"text","text":"implement the "},{"type":"codeVoice","code":"WriteObservingByteToMessageDecoder"},{"text":" protocol will be notified about every outbound write.","type":"text"}],"url":"\/documentation\/niocore\/writeobservingbytetomessagedecoder","role":"symbol","navigatorTitle":[{"text":"WriteObservingByteToMessageDecoder","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LineBasedFrameDecoder":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder","kind":"symbol","url":"\/documentation\/nioextras\/linebasedframedecoder","role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LineBasedFrameDecoder","kind":"identifier"}],"type":"topic","abstract":[{"text":"A decoder that splits incoming ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":"s around line end","type":"text"},{"text":" ","type":"text"},{"text":"character(s) (","type":"text"},{"code":"'\\n'","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"'\\r\\n'","type":"codeVoice"},{"text":").","type":"text"}],"navigatorTitle":[{"text":"LineBasedFrameDecoder","kind":"identifier"}],"title":"LineBasedFrameDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decode(context:buffer:)":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decode(context:buffer:)","kind":"symbol","required":true,"fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"decode"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier","text":"ChannelHandlerContext"},{"kind":"text","text":", "},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"preciseIdentifier":"s:7NIOCore10ByteBufferV","kind":"typeIdentifier","text":"ByteBuffer"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"DecodingState","preciseIdentifier":"s:7NIOCore13DecodingStateO","kind":"typeIdentifier"}],"role":"symbol","type":"topic","url":"\/documentation\/niocore\/bytetomessagedecoder\/decode(context:buffer:)","title":"decode(context:buffer:)","abstract":[{"type":"text","text":"Decode from a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":"."}],"defaultImplementations":1},"doc://co.pointfree.VaporRouting/documentation/NIOWebSocket/WebSocketFrameDecoder":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOWebSocket\/WebSocketFrameDecoder","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WebSocketFrameDecoder","kind":"identifier"}],"url":"\/documentation\/niowebsocket\/websocketframedecoder","title":"WebSocketFrameDecoder","abstract":[{"text":"An inbound ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":" that deserializes websocket frames into a structured","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"format for further processing."}],"navigatorTitle":[{"text":"WebSocketFrameDecoder","kind":"identifier"}],"kind":"symbol","type":"topic","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder":{"kind":"symbol","title":"ByteToMessageDecoder","role":"symbol","url":"\/documentation\/niocore\/bytetomessagedecoder","type":"topic","navigatorTitle":[{"text":"ByteToMessageDecoder","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder","abstract":[{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":"s decode bytes in a stream-like fashion from ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" to another message type.","type":"text"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoder","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOJSONRPCFraming/ContentLengthHeaderFrameDecoder":{"abstract":[{"type":"codeVoice","code":"ContentLengthHeaderFrameDecoder"},{"text":" is responsible for parsing JSON-RPC wire protocol with ‘Content-Length’","type":"text"},{"text":" ","type":"text"},{"text":"HTTP-like headers as used by for example by LSP (Language Server Protocol).","type":"text"}],"role":"symbol","kind":"symbol","type":"topic","navigatorTitle":[{"text":"ContentLengthHeaderFrameDecoder","kind":"identifier"}],"title":"NIOJSONRPCFraming.ContentLengthHeaderFrameDecoder","url":"\/documentation\/nioextras\/niojsonrpcframing\/contentlengthheaderframedecoder","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ContentLengthHeaderFrameDecoder","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPDecoder":{"kind":"symbol","url":"\/documentation\/niohttp1\/httpdecoder","role":"symbol","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":" that parses HTTP\/1-style messages, converting them from"},{"type":"text","text":" "},{"type":"text","text":"unstructured bytes to a sequence of HTTP messages."}],"title":"HTTPDecoder","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPDecoder","kind":"identifier"}],"navigatorTitle":[{"text":"HTTPDecoder","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPDecoder","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LengthFieldBasedFrameDecoder":{"url":"\/documentation\/nioextras\/lengthfieldbasedframedecoder","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"LengthFieldBasedFrameDecoder"}],"title":"LengthFieldBasedFrameDecoder","kind":"symbol","type":"topic","role":"symbol","abstract":[{"type":"text","text":"A decoder that splits the received "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" by the number of bytes specified in a fixed length header"},{"type":"text","text":" "},{"type":"text","text":"contained within the buffer."},{"type":"text","text":" "},{"type":"text","text":"For example, if you received the following four fragmented packets:"},{"type":"text","text":" "},{"type":"text","text":"+—+––+——+––+"},{"type":"text","text":" "},{"type":"text","text":"| A | BC | DEFG | HI |"},{"type":"text","text":" "},{"type":"text","text":"+—+––+——+––+"}],"navigatorTitle":[{"kind":"identifier","text":"LengthFieldBasedFrameDecoder"}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/FixedLengthFrameDecoder":{"title":"FixedLengthFrameDecoder","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"FixedLengthFrameDecoder"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","url":"\/documentation\/nioextras\/fixedlengthframedecoder","abstract":[{"type":"text","text":"A decoder that splits the received "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" by a fixed number"},{"type":"text","text":" "},{"type":"text","text":"of bytes. For example, if you received the following four fragmented packets:"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"FixedLengthFrameDecoder"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/InboundOut":{"url":"\/documentation\/niocore\/bytetomessagedecoder\/inboundout","title":"InboundOut","required":true,"fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"InboundOut"}],"kind":"symbol","abstract":[{"text":"The type of the messages this ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" decodes to.","type":"text"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/InboundOut","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/shouldReclaimBytes(buffer:)-5fn2u":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u","abstract":[{"type":"text","text":"Determine if the read bytes in the given "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" should be reclaimed and their associated memory freed."},{"type":"text","text":" "},{"type":"text","text":"Be aware that reclaiming memory may involve memory copies and so is not free."}],"required":true,"role":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"shouldReclaimBytes","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore10ByteBufferV","text":"ByteBuffer"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:Sb","text":"Bool"}],"defaultImplementations":1,"type":"topic","url":"\/documentation\/niocore\/bytetomessagedecoder\/shouldreclaimbytes(buffer:)-5fn2u","title":"shouldReclaimBytes(buffer:)","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/wrapInboundOut(_:)":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/wrapInboundOut(_:)","role":"symbol","abstract":[],"kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"wrapInboundOut","kind":"identifier"},{"text":"(","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"InboundOut","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"preciseIdentifier":"s:7NIOCore6NIOAnyV","text":"NIOAny","kind":"typeIdentifier"}],"url":"\/documentation\/niocore\/bytetomessagedecoder\/wrapinboundout(_:)","title":"wrapInboundOut(_:)","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decodeLast(context:buffer:seenEOF:)-1tkzf":{"type":"topic","defaultImplementations":2,"role":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"decodeLast","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"buffer","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"inout","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteBuffer","preciseIdentifier":"s:7NIOCore10ByteBufferV","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"seenEOF","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Bool","preciseIdentifier":"s:Sb","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"DecodingState","preciseIdentifier":"s:7NIOCore13DecodingStateO","kind":"typeIdentifier"}],"title":"decodeLast(context:buffer:seenEOF:)","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf","url":"\/documentation\/niocore\/bytetomessagedecoder\/decodelast(context:buffer:seeneof:)-1tkzf","abstract":[{"type":"text","text":"Decode from a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" when no more data is incoming and the "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" is about to leave"},{"type":"text","text":" "},{"type":"text","text":"the pipeline."}],"required":true,"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"title":"NIOCore","abstract":[],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","type":"topic","role":"collection","url":"\/documentation\/niocore","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOTLS/SNIHandler":{"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"SNIHandler"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/SNIHandler","kind":"symbol","url":"\/documentation\/niotls\/snihandler","role":"symbol","abstract":[{"type":"text","text":"A channel handler that can be used to arbitrarily edit a channel"},{"type":"text","text":" "},{"type":"text","text":"pipeline based on the hostname requested in the Server Name Indication"},{"type":"text","text":" "},{"type":"text","text":"portion of the TLS Client Hello."}],"type":"topic","navigatorTitle":[{"kind":"identifier","text":"SNIHandler"}],"title":"SNIHandler"}}}